# Assembly


## Source Code to Execution
- four stages:
    1. Preprocessing
    2. Compiling
    3. Assembling
    4. Linking



### The Four Stages of Compilation
1. Source (main.c) - preprocessing (clang -E)
2. Preprocessed source (main.i) - compile (clang -S)
3. Assembly (main.s) - assemble (clang -c)
4. Object file (main.o) - link (ld)
5. Binary executable



### Disassembling
Binary -> Assembly
$ objdump -S fib



## Why Assembly?
- The assembly reveals what the compiler did and didn't do
- Bugs can arise at a low level. For ex., a bug in the code
might only have an effect when compiling at -03. Furthermore,
sometimes the compiler is the source of the bug!
- You can modify the assembly by hand, when all else fails
- Reverse engineering: You can decipher what a program does
when you only have access to its binary



## Expectations in knowledge of Assembly
- Understand how a compiler implements C linguistic
constructs using x86 instructions.
- Demonstrate a proficiency in reading x86 assembly language
(with the aid of an architecture manual).
- Understand the high-level perfomance implications of
common assembly patterns.
- Be able to make simple modifications to the x86 assembly
language generated by a compiler.
- use compiler intrinsic functions to use assembly instructions
not directly available in C.
- Know how to go about writing your own assembly code from
scratch if the situation demands it.



## Outline
- x86-64 ISA Primer
- Floating-Point and Vector Hardware
- Overview of Computer Architecture



## The Instruction Set Architecture
> The instruction set architectre (ISA) specifies the syntax
and semantics of assembly.
    - Registers
    - Instructions
    - Data types
    - Memory addressing modes



### x86-64 Registers
- Registers = working memory

> The x86-64 general-purpose registers are aliased:
each has multiple names, which refer to overlapping bytes
in the register.

> Only %rax, %rbx, %rcx, and %rdx have a separate register
name for this byte.



### x86-64 Instruction Format
> Format: <opcode> <operand_list>
    - <opcode> is a short mnemonic identifying the type
    of instruction.
    - <operand_list> is 0, 1, 2 or rarely 3 operands,
    separated by commas.
    - Typically, all operands are sources, and one operand
    might also be the destination.
         
> Example: add1(opcode) %edi(Operand list), %ecx(Destination operand)



### x86-64 Data Types
- C declaration | C constant | x86-64 size (bytes) | Assembly suffix | x86-64 data type
- char          | 'c'        | 1                   | b               | Byte
- short         | 172        | 2                   | w               | Word
- int           | 172        | 4                   | l or d          | Double word
- unsigned int  | 172U       | 8                   | l or d          | Double word
- long          | 172L       | 8                   | q               | Quad word
- unsigned long | 172UL      | 8                   | q               | Quad word
- char *        | "6.172"    | 8                   | q               | Quad word
- float         | 6.172F     | 4                   | s               | Single precision
- double        | 6.172      | 8                   | d               | Double precision
- long double   | 6.172L     | 16(10)              | t               | Extended precision



#### Opcode Suffixes for Extension
> Sign-extension or zero-extension opcodes use two
data-type suffixes.

> Examples: movzbl %al, %edx, movslq %eax, %rdx

> Results of 32-bit operations are implicitly zero-extended
to 64-bit values, unlike the results of 8- and 16-bit operations.



### x86-64 Direct Addresiing Modes
> The operands of an instruction speicfy values using a
variety of addressing modes.

- At most one operand may specifya memory address.

- Direct addressing modes
    - Immediate: Use the specified value.
    - Register: Use the value in the specified register.
    - Direct memory: Use the value at athe specified memory address.

- Examples:
    - movq $172, %rdi
    - movq %rcx, %rdi
    - movq 0x172, %rdi



### x86-64 Indirect Addressing Modes
> The x86-64 ISA also supports indirect addressing: specifying
a memory address by some computation.

- Indirect addressing modes
    - Register indirect: The address is stored in the 
    specified register.
    - Register indexed: The address is a constant offset of the value
    in the specified register.
    - Instruction-pointer relative: The address is indexed 
    relative to %rip.

- Examples:
    - movq (%rax), %rdi
    - movq 172(%rax), %rdi
    - movq 172(%rip), %rdi



#### Base indexed Scale Displacement
> The most general form of indirect addressing supported
by x86-64 is the base indexed scale displacement mode.

- Example: movq 172(%rdi, %rdx, 8), %rax

> This mode refers to the address Base + Index*Scale +
Displacement. If unspecified, Index and Displacement default
to 0, and Scale defaults to 1.



### Jump Instructions
> The x86-64 jump instructions, jmp and j(condition), take a
label as their operand, which identifies a location in the code.

- Labels can be symbols, exact addresses, or relative addresses.
- An indirect jump takes as its operand an indirect address.
as its operand.

> Example: jmp *%eax

- Example from fib.s
```
jge LBBO_1
LBB0_1:
    leaq -1(%rbx), %rdi
```
- Example from objdump fib
```
jge 5 <_fib+0x15>
15:
    leaq -1(%rbx), %rdi
```



### Assembly Idiom 1
> The XOR opcode, "xor A, B" computes the bitwise XOR of A and B.

- Example: xor %rax, %rax

> In this examples it zeros the register. When you XOR something
with itself you get 0. Storing that back into it.



### Assembly Idiom 2
> The test opcode, "test A, B" computes the bitwise
AND of A and B and discard the resutl, preserving the RFLAGS
register.

- Checks to see whether the register is 0.
```
test %rcx, %rcx
je 400c-a <mm+0xda>
```



### Assembly Idiom 3
> The x86-64 ISA includes several no-op (no operation) instructions,
including "nop", "nop A," (no-op with an argument), and "data16."

- Example: data16 data16 data16 nopw %cs:0x0(%rax, %rax, 1)

- This code in the example does nothing.

- Why would the compiler generate assembly with these idioms?
- Mainly, to optimize instruction memory (e.g., code, size, alignment).  
 
